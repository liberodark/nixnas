use crate::commands::runner::{run, run_lines};
use crate::error::{CmdResult, NixError};
use crate::state::{NasState, PersistentMount, SmbShare, SnapshotPolicy, StateManager};
use serde::Serialize;
use std::fmt::Write;
use std::path::Path;
use std::sync::Arc;
use tokio::fs;
use tracing::info;

/// NixOS configuration generator.
pub struct NixGenerator {
    state: Arc<StateManager>,
    output_dir: String,
}

impl NixGenerator {
    pub fn new(state: Arc<StateManager>, output_dir: &str) -> Self {
        Self {
            state,
            output_dir: output_dir.to_string(),
        }
    }

    /// Generate all configuration files.
    pub async fn generate_all(&self) -> Result<(), NixError> {
        let nas_dir = Path::new(&self.output_dir).join("nas");
        fs::create_dir_all(&nas_dir)
            .await
            .map_err(|e| NixError::Write(e.to_string()))?;

        let state = self.state.get().await;

        self.generate_default(&nas_dir, &state).await?;
        self.generate_storage(&nas_dir, &state).await?;
        self.generate_zfs(&nas_dir, &state).await?;
        self.generate_snapshots(&nas_dir, &state).await?;
        self.generate_users(&nas_dir, &state).await?;
        self.generate_samba(&nas_dir, &state).await?;
        self.generate_nfs(&nas_dir, &state).await?;
        self.generate_ssh(&nas_dir, &state).await?;
        self.generate_rsyncd(&nas_dir, &state).await?;
        self.generate_smartd(&nas_dir, &state).await?;

        info!("Generated NixOS configuration files in {}", self.output_dir);
        Ok(())
    }

    /// Generate default.nix (imports all modules + system settings).
    async fn generate_default(&self, dir: &Path, state: &NasState) -> Result<(), NixError> {
        let hostname = &state.settings.hostname;
        let workgroup = &state.smb.workgroup;

        let content = format!(
            r#"# Auto-generated by nixnas-daemon
# DO NOT EDIT MANUALLY
{{ ... }}:

{{
  imports = [
    ./storage.nix
    ./zfs.nix
    ./snapshots.nix
    ./users.nix
    ./samba.nix
    ./nfs.nix
    ./ssh.nix
    ./rsyncd.nix
    ./smartd.nix
  ];

  # System identity
  networking.hostName = "{hostname}";

  # Enable Avahi for macOS/Linux service discovery (mDNS)
  services.avahi = {{
    enable = true;
    nssmdns4 = true;
    publish = {{
      enable = true;
      addresses = true;
      workstation = true;
    }};
  }};

  # Enable WSDD for Windows network discovery (WS-Discovery)
  services.samba-wsdd = {{
    enable = true;
    openFirewall = true;
    workgroup = "{workgroup}";
    hostname = "{hostname}";
    discovery = true;
  }};
}}
"#,
            hostname = hostname,
            workgroup = workgroup
        );
        self.write_file(dir.join("default.nix"), &content).await
    }

    /// Generate storage.nix (fileSystems).
    async fn generate_storage(&self, dir: &Path, state: &NasState) -> Result<(), NixError> {
        let mut content = String::new();

        writeln!(content, "# Auto-generated by nixnas-daemon").unwrap();
        writeln!(content, "# Storage configuration - DO NOT EDIT MANUALLY").unwrap();
        writeln!(content, "{{ ... }}:\n").unwrap();
        writeln!(content, "{{").unwrap();

        if state.mounts.is_empty() {
            writeln!(content, "  # No persistent mounts configured").unwrap();
        } else {
            writeln!(content, "  fileSystems = {{").unwrap();

            for mount in &state.mounts {
                self.write_mount(&mut content, mount)?;
            }

            writeln!(content, "  }};").unwrap();
        }

        writeln!(content, "}}").unwrap();

        self.write_file(dir.join("storage.nix"), &content).await
    }

    /// Generate zfs.nix (ZFS pool imports and settings).
    async fn generate_zfs(&self, dir: &Path, state: &NasState) -> Result<(), NixError> {
        let mut content = String::new();
        let zfs = &state.zfs_settings;

        writeln!(content, "# Auto-generated by nixnas-daemon").unwrap();
        writeln!(content, "# ZFS configuration - DO NOT EDIT MANUALLY").unwrap();
        writeln!(content, "{{ ... }}:\n").unwrap();
        writeln!(content, "{{").unwrap();

        // ARC max size (memory limit for ZFS cache)
        if zfs.arc_max_gb > 0 {
            let arc_max_bytes = u64::from(zfs.arc_max_gb) * 1024 * 1024 * 1024;
            writeln!(content, "  # Limit ZFS ARC cache size").unwrap();
            writeln!(
                content,
                "  boot.kernelParams = [ \"zfs.zfs_arc_max={}\" ];",
                arc_max_bytes
            )
            .unwrap();
            writeln!(content).unwrap();
        }

        // Device nodes path (for VMs that need /dev/disk/by-path)
        if let Some(ref dev_nodes) = zfs.dev_nodes {
            writeln!(content, "  # Device nodes path for pool discovery").unwrap();
            writeln!(content, "  boot.zfs.devNodes = \"{}\";", dev_nodes).unwrap();
            writeln!(content).unwrap();
        }

        // Note: Pools with datasets in fileSystems are auto-imported by NixOS
        if !zfs.extra_pools.is_empty() {
            writeln!(content, "  # Extra pools to import at boot").unwrap();
            writeln!(content, "  boot.zfs.extraPools = [").unwrap();
            for pool in &zfs.extra_pools {
                writeln!(content, "    \"{}\"", pool).unwrap();
            }
            writeln!(content, "  ];").unwrap();
            writeln!(content).unwrap();
        }

        // Force import all
        if zfs.force_import_all {
            writeln!(
                content,
                "  # Force import pools (even if used by another system)"
            )
            .unwrap();
            writeln!(content, "  boot.zfs.forceImportAll = true;").unwrap();
            writeln!(content).unwrap();
        }

        // Auto scrub - only output if enabled (default is disabled)
        if zfs.auto_scrub_enable {
            writeln!(content, "  # Automatic scrubbing").unwrap();
            writeln!(content, "  services.zfs.autoScrub = {{").unwrap();
            writeln!(content, "    enable = true;").unwrap();
            writeln!(content, "    interval = \"{}\";", zfs.auto_scrub_interval).unwrap();
            if !zfs.auto_scrub_pools.is_empty() {
                writeln!(content, "    pools = [").unwrap();
                for pool in &zfs.auto_scrub_pools {
                    writeln!(content, "      \"{}\"", pool).unwrap();
                }
                writeln!(content, "    ];").unwrap();
            }
            writeln!(content, "  }};").unwrap();
            writeln!(content).unwrap();
        }

        // Trim - only output if explicitly disabled (default is enabled)
        if !zfs.trim_enable {
            writeln!(content, "  # Disable automatic TRIM").unwrap();
            writeln!(content, "  services.zfs.trim.enable = false;").unwrap();
        }

        writeln!(content, "}}").unwrap();

        self.write_file(dir.join("zfs.nix"), &content).await
    }

    /// Generate snapshots.nix (ZFS automatic snapshots using systemd timers).
    async fn generate_snapshots(&self, dir: &Path, state: &NasState) -> Result<(), NixError> {
        let mut content = String::new();

        writeln!(content, "# Auto-generated by nixnas-daemon").unwrap();
        writeln!(
            content,
            "# ZFS Snapshot configuration - DO NOT EDIT MANUALLY"
        )
        .unwrap();
        writeln!(content, "{{ pkgs, ... }}:\n").unwrap();
        writeln!(content, "{{").unwrap();

        let enabled_policies: Vec<&SnapshotPolicy> = state
            .snapshot_policies
            .iter()
            .filter(|p| p.enabled)
            .collect();

        if enabled_policies.is_empty() {
            writeln!(content, "  # No snapshot policies configured").unwrap();
        } else {
            writeln!(content, "  # ZFS snapshot management script").unwrap();
            writeln!(content, "  environment.systemPackages = [").unwrap();
            writeln!(content, "    (pkgs.writeShellApplication {{").unwrap();
            writeln!(content, "      name = \"zfs-snap\";").unwrap();
            writeln!(
                content,
                "      runtimeInputs = [ pkgs.zfs pkgs.coreutils pkgs.gnugrep pkgs.findutils ];"
            )
            .unwrap();
            writeln!(content, "      text = ''").unwrap();
            writeln!(content, "        DATASET=\"$1\"").unwrap();
            writeln!(content, "        TYPE=\"$2\"").unwrap();
            writeln!(content, "        KEEP=\"$3\"").unwrap();
            writeln!(content, "        RECURSIVE=\"$4\"").unwrap();
            writeln!(content).unwrap();
            writeln!(
                content,
                "        SNAP_NAME=\"$DATASET@''${{TYPE}}_$(date +%Y%m%dT%H%M%S)\""
            )
            .unwrap();
            writeln!(content).unwrap();
            writeln!(content, "        if [ \"$RECURSIVE\" = \"true\" ]; then").unwrap();
            writeln!(content, "          zfs snapshot -r \"$SNAP_NAME\"").unwrap();
            writeln!(content, "        else").unwrap();
            writeln!(content, "          zfs snapshot \"$SNAP_NAME\"").unwrap();
            writeln!(content, "        fi").unwrap();
            writeln!(content).unwrap();
            writeln!(content, "        # Prune old snapshots").unwrap();
            writeln!(content, "        zfs list -t snapshot -o name -s creation | grep \"$DATASET@''${{TYPE}}_\" | head -n -\"$KEEP\" | xargs -r -n1 zfs destroy").unwrap();
            writeln!(
                content,
                "        echo \"Snapshot $TYPE created for $DATASET - Retention: $KEEP\""
            )
            .unwrap();
            writeln!(content, "      '';").unwrap();
            writeln!(content, "    }})").unwrap();
            writeln!(content, "  ];").unwrap();
            writeln!(content).unwrap();

            writeln!(content, "  systemd.services = {{").unwrap();

            for policy in &enabled_policies {
                let safe_name = policy.name.replace([' ', '/'], "-");

                for (snap_type, count, _calendar) in [
                    ("hourly", policy.hourly, "*:00:00"),
                    ("daily", policy.daily, "*-*-* 00:00:00"),
                    ("weekly", policy.weekly, "Sun *-*-* 00:00:00"),
                    ("monthly", policy.monthly, "*-*-01 00:00:00"),
                    ("yearly", policy.yearly, "*-01-01 00:00:00"),
                ] {
                    if count > 0 {
                        writeln!(content).unwrap();
                        writeln!(content, "    \"zfs-snap-{}-{}\" = {{", safe_name, snap_type)
                            .unwrap();
                        writeln!(
                            content,
                            "      description = \"ZFS {} snapshot for {}\";",
                            snap_type, policy.dataset
                        )
                        .unwrap();
                        writeln!(content, "      serviceConfig.Type = \"oneshot\";").unwrap();
                        writeln!(content, "      script = ''").unwrap();
                        writeln!(content, "        /run/current-system/sw/bin/zfs-snap \"{}\" \"{}\" \"{}\" \"{}\"",
                            policy.dataset, snap_type, count, policy.recursive).unwrap();
                        writeln!(content, "      '';").unwrap();
                        writeln!(content, "      after = [ \"zfs.target\" ];").unwrap();
                        writeln!(content, "    }};").unwrap();
                    }
                }
            }

            writeln!(content, "  }};").unwrap();
            writeln!(content).unwrap();

            writeln!(content, "  systemd.timers = {{").unwrap();

            for policy in &enabled_policies {
                let safe_name = policy.name.replace([' ', '/'], "-");

                for (snap_type, count, calendar) in [
                    ("hourly", policy.hourly, "*:00:00"),
                    ("daily", policy.daily, "*-*-* 00:00:00"),
                    ("weekly", policy.weekly, "Sun *-*-* 00:00:00"),
                    ("monthly", policy.monthly, "*-*-01 00:00:00"),
                    ("yearly", policy.yearly, "*-01-01 00:00:00"),
                ] {
                    if count > 0 {
                        writeln!(content).unwrap();
                        writeln!(content, "    \"zfs-snap-{}-{}\" = {{", safe_name, snap_type)
                            .unwrap();
                        writeln!(content, "      wantedBy = [ \"timers.target\" ];").unwrap();
                        writeln!(content, "      timerConfig = {{").unwrap();
                        writeln!(content, "        OnCalendar = \"{}\";", calendar).unwrap();
                        writeln!(content, "        Persistent = true;").unwrap();
                        writeln!(content, "      }};").unwrap();
                        writeln!(content, "    }};").unwrap();
                    }
                }
            }

            writeln!(content, "  }};").unwrap();
        }

        writeln!(content, "}}").unwrap();

        self.write_file(dir.join("snapshots.nix"), &content).await
    }

    /// Generate users.nix (system users and groups for Samba).
    /// Generate samba.nix.
    async fn generate_samba(&self, dir: &Path, state: &NasState) -> Result<(), NixError> {
        let mut content = String::new();
        let smb = &state.smb;

        writeln!(content, "# Auto-generated by nixnas-daemon").unwrap();
        writeln!(content, "# Samba configuration - DO NOT EDIT MANUALLY").unwrap();
        writeln!(content, "{{ ... }}:\n").unwrap();
        writeln!(content, "{{").unwrap();

        writeln!(content, "  services.samba = {{").unwrap();
        writeln!(content, "    enable = {};", smb.enabled).unwrap();
        writeln!(content, "    openFirewall = true;").unwrap();
        writeln!(content).unwrap();
        writeln!(content, "    settings = {{").unwrap();
        writeln!(content, "      global = {{").unwrap();
        writeln!(content, "        workgroup = \"{}\";", smb.workgroup).unwrap();
        writeln!(
            content,
            "        \"server string\" = \"{}\";",
            smb.server_string
        )
        .unwrap();
        writeln!(content, "        security = \"user\";").unwrap();
        writeln!(content, "        \"map to guest\" = \"Bad User\";").unwrap();
        writeln!(
            content,
            "        \"guest account\" = \"{}\";",
            smb.guest_account
        )
        .unwrap();

        writeln!(
            content,
            "        \"server min protocol\" = \"{}\";",
            smb.min_protocol
        )
        .unwrap();

        if smb.disable_netbios {
            writeln!(content, "        \"disable netbios\" = \"yes\";").unwrap();
        }
        if smb.wins_support {
            writeln!(content, "        \"wins support\" = \"yes\";").unwrap();
        }
        if !smb.wins_server.is_empty() {
            writeln!(
                content,
                "        \"wins server\" = \"{}\";",
                smb.wins_server
            )
            .unwrap();
        }

        writeln!(
            content,
            "        \"unix extensions\" = \"{}\";",
            bool_to_yesno(smb.unix_extensions)
        )
        .unwrap();

        if smb.use_sendfile {
            writeln!(content, "        \"use sendfile\" = \"yes\";").unwrap();
        }
        if smb.aio_enabled {
            writeln!(content, "        \"aio read size\" = \"1\";").unwrap();
            writeln!(content, "        \"aio write size\" = \"1\";").unwrap();
        }

        if smb.time_server {
            writeln!(content, "        \"time server\" = \"yes\";").unwrap();
        }

        writeln!(
            content,
            "        \"create mask\" = \"{}\";",
            smb.global_create_mask
        )
        .unwrap();
        writeln!(
            content,
            "        \"directory mask\" = \"{}\";",
            smb.global_directory_mask
        )
        .unwrap();

        if smb.log_level > 0 {
            writeln!(content, "        \"log level\" = \"{}\";", smb.log_level).unwrap();
        }

        writeln!(content, "        \"load printers\" = \"no\";").unwrap();
        writeln!(content, "        \"disable spoolss\" = \"yes\";").unwrap();
        writeln!(content, "        printing = \"bsd\";").unwrap();
        writeln!(content, "        \"printcap name\" = \"/dev/null\";").unwrap();

        if smb.time_machine_support {
            writeln!(content, "        \"fruit:aapl\" = \"yes\";").unwrap();
            writeln!(content, "        \"fruit:copyfile\" = \"yes\";").unwrap();
            writeln!(content, "        \"fruit:nfs_aces\" = \"no\";").unwrap();
        }

        if !smb.extra_options.is_empty() {
            for line in smb.extra_options.lines() {
                let line = line.trim();
                if !line.is_empty()
                    && !line.starts_with('#')
                    && let Some((key, value)) = line.split_once('=')
                {
                    writeln!(
                        content,
                        "        \"{}\" = \"{}\";",
                        key.trim(),
                        value.trim()
                    )
                    .unwrap();
                }
            }
        }

        writeln!(content, "      }};").unwrap();

        if smb.homes_enabled {
            writeln!(content).unwrap();
            writeln!(content, "      homes = {{").unwrap();
            writeln!(
                content,
                "        browseable = \"{}\";",
                bool_to_yesno(smb.homes_browseable)
            )
            .unwrap();
            writeln!(content, "        \"read only\" = \"no\";").unwrap();
            writeln!(content, "        \"valid users\" = \"%S\";").unwrap();
            if smb.homes_inherit_acls {
                writeln!(content, "        \"inherit acls\" = \"yes\";").unwrap();
            }
            if smb.homes_inherit_permissions {
                writeln!(content, "        \"inherit permissions\" = \"yes\";").unwrap();
            }
            writeln!(
                content,
                "        \"follow symlinks\" = \"{}\";",
                bool_to_yesno(smb.homes_follow_symlinks)
            )
            .unwrap();
            writeln!(
                content,
                "        \"wide links\" = \"{}\";",
                bool_to_yesno(smb.homes_wide_links)
            )
            .unwrap();

            if smb.homes_recycle_bin {
                writeln!(content, "        \"vfs objects\" = \"recycle\";").unwrap();
                writeln!(content, "        \"recycle:repository\" = \".recycle\";").unwrap();
                writeln!(content, "        \"recycle:keeptree\" = \"yes\";").unwrap();
                writeln!(content, "        \"recycle:versions\" = \"yes\";").unwrap();
            }

            if !smb.homes_extra_options.is_empty() {
                for line in smb.homes_extra_options.lines() {
                    let line = line.trim();
                    if !line.is_empty()
                        && !line.starts_with('#')
                        && let Some((key, value)) = line.split_once('=')
                    {
                        writeln!(
                            content,
                            "        \"{}\" = \"{}\";",
                            key.trim(),
                            value.trim()
                        )
                        .unwrap();
                    }
                }
            }

            writeln!(content, "      }};").unwrap();
        }

        for share in &smb.shares {
            self.write_smb_share(&mut content, share)?;
        }

        writeln!(content, "    }};").unwrap();
        writeln!(content, "  }};").unwrap();
        writeln!(content, "}}").unwrap();

        self.write_file(dir.join("samba.nix"), &content).await
    }

    /// Generate nfs.nix.
    async fn generate_nfs(&self, dir: &Path, state: &NasState) -> Result<(), NixError> {
        let mut content = String::new();

        writeln!(content, "# Auto-generated by nixnas-daemon").unwrap();
        writeln!(content, "# NFS configuration - DO NOT EDIT MANUALLY").unwrap();
        writeln!(content, "{{ ... }}:\n").unwrap();
        writeln!(content, "{{").unwrap();

        writeln!(content, "  services.nfs.server = {{").unwrap();
        writeln!(content, "    enable = {};", state.nfs.enabled).unwrap();

        if state.nfs.threads != 8 {
            writeln!(content, "    nproc = {};", state.nfs.threads).unwrap();
        }

        if state.nfs.enabled && !state.nfs.exports.is_empty() {
            writeln!(content, "    exports = ''").unwrap();
            for export in &state.nfs.exports {
                writeln!(content, "      {}", export.to_exports_line()).unwrap();
            }
            writeln!(content, "    '';").unwrap();
        }

        writeln!(content, "  }};").unwrap();

        // Firewall for NFS
        if state.nfs.enabled {
            writeln!(content).unwrap();
            writeln!(content, "  networking.firewall.allowedTCPPorts = [ 2049 ];").unwrap();
            writeln!(content, "  networking.firewall.allowedUDPPorts = [ 2049 ];").unwrap();
        }

        writeln!(content, "}}").unwrap();

        self.write_file(dir.join("nfs.nix"), &content).await
    }

    /// Generate ssh.nix (SSH server configuration).
    async fn generate_ssh(&self, dir: &Path, state: &NasState) -> Result<(), NixError> {
        let mut content = String::new();

        writeln!(content, "# Auto-generated by nixnas-daemon").unwrap();
        writeln!(content, "# SSH configuration - DO NOT EDIT MANUALLY").unwrap();
        writeln!(content, "{{ ... }}:\n").unwrap();
        writeln!(content, "{{").unwrap();

        writeln!(content, "  services.openssh = {{").unwrap();
        writeln!(content, "    enable = {};", state.settings.ssh_enabled).unwrap();

        if state.settings.ssh_port != 22 {
            writeln!(content, "    ports = [ {} ];", state.settings.ssh_port).unwrap();
        }

        writeln!(content, "    settings = {{").unwrap();
        writeln!(
            content,
            "      PermitRootLogin = \"{}\";",
            if state.settings.ssh_permit_root_login {
                "yes"
            } else {
                "no"
            }
        )
        .unwrap();
        writeln!(
            content,
            "      PasswordAuthentication = {};",
            state.settings.ssh_password_auth
        )
        .unwrap();
        writeln!(
            content,
            "      PubkeyAuthentication = {};",
            state.settings.ssh_pubkey_auth
        )
        .unwrap();
        writeln!(content, "    }};").unwrap();

        writeln!(content, "  }};").unwrap();

        if state.settings.ssh_enabled {
            writeln!(content).unwrap();
            writeln!(
                content,
                "  networking.firewall.allowedTCPPorts = [ {} ];",
                state.settings.ssh_port
            )
            .unwrap();
        }

        writeln!(content, "}}").unwrap();

        self.write_file(dir.join("ssh.nix"), &content).await
    }

    /// Generate rsyncd.nix (rsync daemon configuration).
    async fn generate_rsyncd(&self, dir: &Path, state: &NasState) -> Result<(), NixError> {
        let mut content = String::new();

        writeln!(content, "# Auto-generated by nixnas-daemon").unwrap();
        writeln!(
            content,
            "# Rsync daemon configuration - DO NOT EDIT MANUALLY"
        )
        .unwrap();
        writeln!(content, "{{ ... }}:\n").unwrap();
        writeln!(content, "{{").unwrap();

        writeln!(content, "  services.rsyncd = {{").unwrap();
        writeln!(content, "    enable = {};", state.settings.rsync_enabled).unwrap();

        if state.settings.rsync_enabled && !state.rsync_modules.is_empty() {
            writeln!(content, "    settings = {{").unwrap();
            writeln!(content, "      globalSection = {{").unwrap();
            writeln!(content, "        \"use chroot\" = true;").unwrap();
            writeln!(content, "        \"max connections\" = 0;").unwrap();
            writeln!(content, "      }};").unwrap();

            for module in &state.rsync_modules {
                writeln!(content, "      \"{}\" = {{", module.name).unwrap();
                writeln!(content, "        path = \"{}\";", module.path).unwrap();

                if !module.comment.is_empty() {
                    writeln!(content, "        comment = \"{}\";", module.comment).unwrap();
                }

                writeln!(content, "        uid = \"{}\";", module.uid).unwrap();
                writeln!(content, "        gid = \"{}\";", module.gid).unwrap();

                writeln!(content, "        \"use chroot\" = {};", module.use_chroot).unwrap();
                if module.auth_users {
                    writeln!(content, "        \"auth users\" = \"*\";").unwrap();
                }

                writeln!(content, "        \"read only\" = {};", module.read_only).unwrap();
                writeln!(content, "        \"write only\" = {};", module.write_only).unwrap();
                writeln!(content, "        list = {};", module.list).unwrap();

                if module.max_connections > 0 {
                    writeln!(
                        content,
                        "        \"max connections\" = {};",
                        module.max_connections
                    )
                    .unwrap();
                }

                if !module.hosts_allow.is_empty() {
                    writeln!(
                        content,
                        "        \"hosts allow\" = \"{}\";",
                        module.hosts_allow
                    )
                    .unwrap();
                }
                if !module.hosts_deny.is_empty() {
                    writeln!(
                        content,
                        "        \"hosts deny\" = \"{}\";",
                        module.hosts_deny
                    )
                    .unwrap();
                }

                for line in module.extra_options.lines() {
                    let line = line.trim();
                    if !line.is_empty() && line.contains('=') {
                        let parts: Vec<&str> = line.splitn(2, '=').collect();
                        if parts.len() == 2 {
                            let key = parts[0].trim();
                            let value = parts[1].trim();
                            writeln!(content, "        \"{}\" = \"{}\";", key, value).unwrap();
                        }
                    }
                }

                writeln!(content, "      }};").unwrap();
            }
            writeln!(content, "    }};").unwrap();
        }

        writeln!(content, "  }};").unwrap();

        // Firewall for rsync (port 873)
        if state.settings.rsync_enabled {
            writeln!(content).unwrap();
            writeln!(content, "  networking.firewall.allowedTCPPorts = [ 873 ];").unwrap();
        }

        writeln!(content, "}}").unwrap();

        self.write_file(dir.join("rsyncd.nix"), &content).await
    }

    /// Generate smartd.nix (SMART monitoring daemon configuration).
    async fn generate_smartd(&self, dir: &Path, state: &NasState) -> Result<(), NixError> {
        use crate::commands::filesystem::get_disk_by_id_map;
        use std::fmt::Write;
        let mut content = String::new();

        writeln!(content, "# Auto-generated by nixnas-daemon").unwrap();
        writeln!(content, "# SMART monitoring daemon - DO NOT EDIT MANUALLY").unwrap();
        writeln!(content, "{{ ... }}:\n").unwrap();
        writeln!(content, "{{").unwrap();

        let enabled_configs: Vec<_> = state
            .settings
            .smart_configs
            .iter()
            .filter(|c| c.enabled)
            .collect();

        if enabled_configs.is_empty() {
            // No SMART monitoring enabled
            writeln!(content, "  # SMART monitoring disabled").unwrap();
            writeln!(content, "  services.smartd.enable = false;").unwrap();
        } else {
            let by_id_map = get_disk_by_id_map().await.unwrap_or_default();

            let check_interval = enabled_configs
                .first()
                .map(|c| c.check_interval)
                .unwrap_or(1800);

            writeln!(content, "  # Enable SMART monitoring daemon").unwrap();
            writeln!(content, "  services.smartd = {{").unwrap();
            writeln!(content, "    enable = true;").unwrap();
            writeln!(content, "    autodetect = false;").unwrap();
            writeln!(
                content,
                "    extraOptions = [ \"-i {}\" ];  # Check interval in seconds",
                check_interval
            )
            .unwrap();
            writeln!(content).unwrap();

            if state.notifications.enabled && !state.notifications.smtp.server.is_empty() {
                writeln!(content, "    notifications = {{").unwrap();
                writeln!(content, "      mail = {{").unwrap();
                writeln!(content, "        enable = true;").unwrap();
                writeln!(
                    content,
                    "        recipient = \"{}\";",
                    state.notifications.smtp.recipient
                )
                .unwrap();
                if !state.notifications.smtp.sender.is_empty() {
                    writeln!(
                        content,
                        "        sender = \"{}\";",
                        state.notifications.smtp.sender
                    )
                    .unwrap();
                }
                writeln!(content, "      }};").unwrap();
                writeln!(content, "      wall.enable = true;").unwrap();
                writeln!(content, "    }};").unwrap();
                writeln!(content).unwrap();
            }

            writeln!(content, "    devices = [").unwrap();
            for cfg in &enabled_configs {
                // Skip disks without by-id (likely virtual disks without SMART)
                let Some(device_path) = by_id_map.get(&cfg.disk_name) else {
                    continue;
                };

                let mut options = String::from("-a"); // Monitor all attributes

                match cfg.power_mode {
                    crate::state::SmartPowerMode::Never => {}
                    crate::state::SmartPowerMode::Sleep => {
                        write!(options, " -n sleep,7").unwrap();
                    }
                    crate::state::SmartPowerMode::Standby => {
                        write!(options, " -n standby,7").unwrap();
                    }
                    crate::state::SmartPowerMode::Idle => {
                        write!(options, " -n idle,7").unwrap();
                    }
                }

                let temp_diff = cfg.temp_difference.unwrap_or(0);
                let temp_info = cfg.temp_max.saturating_sub(5);
                let temp_crit = cfg.temp_max;
                write!(options, " -W {},{},{}", temp_diff, temp_info, temp_crit).unwrap();

                write!(options, " -s (S/../.././02|L/../../7/04)").unwrap();

                writeln!(
                    content,
                    "      {{ device = \"{}\"; options = \"{}\"; }}",
                    device_path, options
                )
                .unwrap();
            }
            writeln!(content, "    ];").unwrap();

            writeln!(content).unwrap();
            writeln!(content, "    defaults.monitored = \"-a\";").unwrap();
            writeln!(content, "  }};").unwrap();
        }

        writeln!(content, "}}").unwrap();

        self.write_file(dir.join("smartd.nix"), &content).await
    }

    /// Generate users.nix (system users and groups).
    async fn generate_users(&self, dir: &Path, state: &NasState) -> Result<(), NixError> {
        let mut content = String::new();

        writeln!(content, "# Auto-generated by nixnas-daemon").unwrap();
        writeln!(content, "# System users and groups - DO NOT EDIT MANUALLY").unwrap();
        writeln!(content, "{{ ... }}:\n").unwrap();
        writeln!(content, "{{").unwrap();

        let _has_samba_users = state
            .system_users
            .iter()
            .any(|u| u.samba_access && u.enabled);
        let has_system_groups = !state.system_groups.is_empty();
        let has_system_users = !state.system_users.is_empty();

        let legacy_samba_users: Vec<&crate::state::SambaUser> =
            state.smb.users.iter().filter(|u| u.enabled).collect();
        let has_legacy_samba = !legacy_samba_users.is_empty();

        if has_system_groups {
            writeln!(content, "  users.groups = {{").unwrap();

            for group in &state.system_groups {
                writeln!(content, "    \"{}\" = {{", group.name).unwrap();
                if let Some(gid) = group.gid {
                    writeln!(content, "      gid = {};", gid).unwrap();
                }
                if !group.members.is_empty() {
                    let members: Vec<String> =
                        group.members.iter().map(|m| format!("\"{}\"", m)).collect();
                    writeln!(content, "      members = [ {} ];", members.join(" ")).unwrap();
                }
                writeln!(content, "    }};").unwrap();
            }

            writeln!(content, "  }};").unwrap();
            writeln!(content).unwrap();
        }

        if has_system_users || has_legacy_samba {
            writeln!(content, "  users.users = {{").unwrap();

            let mut created_users: Vec<String> = Vec::new();

            for user in &state.system_users {
                if !user.enabled {
                    continue;
                }

                created_users.push(user.username.clone());

                writeln!(content, "    \"{}\" = {{", user.username).unwrap();

                let is_login_user = !user.shell.contains("nologin");

                if is_login_user {
                    writeln!(content, "      isNormalUser = true;").unwrap();
                } else {
                    writeln!(content, "      isSystemUser = true;").unwrap();
                    writeln!(content, "      group = \"users\";").unwrap();
                }

                if !user.description.is_empty() {
                    writeln!(content, "      description = \"{}\";", user.description).unwrap();
                }

                if let Some(uid) = user.uid {
                    writeln!(content, "      uid = {};", uid).unwrap();
                } else if !is_login_user {
                    // Auto-assign UID for system users (start at 900 to avoid conflicts)
                    let auto_uid = 900 + created_users.len();
                    writeln!(content, "      uid = {};", auto_uid).unwrap();
                }

                if is_login_user {
                    if let Some(ref home) = user.home_dir {
                        writeln!(content, "      home = \"{}\";", home).unwrap();
                    }
                    writeln!(content, "      createHome = {};", user.create_home).unwrap();

                    if !user.shell.is_empty() && user.shell != "/bin/sh" {
                        let shell = match user.shell.as_str() {
                            "/bin/bash" | "/usr/bin/bash" => "pkgs.bash",
                            "/bin/zsh" | "/usr/bin/zsh" => "pkgs.zsh",
                            "/bin/fish" | "/usr/bin/fish" => "pkgs.fish",
                            _ => "pkgs.bash",
                        };
                        writeln!(
                            content,
                            "      shell = {}/bin/{};",
                            shell,
                            user.shell.split('/').next_back().unwrap_or("bash")
                        )
                        .unwrap();
                    }
                } else {
                    writeln!(content, "      home = \"/var/empty\";").unwrap();
                    writeln!(
                        content,
                        "      shell = \"/run/current-system/sw/bin/nologin\";"
                    )
                    .unwrap();
                    writeln!(content, "      createHome = false;").unwrap();
                }

                let extra_groups: Vec<String> = user
                    .groups
                    .iter()
                    .filter(|g| *g != "users" && *g != "samba")
                    .map(|g| format!("\"{}\"", g))
                    .collect();
                if !extra_groups.is_empty() {
                    writeln!(
                        content,
                        "      extraGroups = [ {} ];",
                        extra_groups.join(" ")
                    )
                    .unwrap();
                }

                if !user.ssh_keys.is_empty() {
                    writeln!(content, "      openssh.authorizedKeys.keys = [").unwrap();
                    for key in &user.ssh_keys {
                        writeln!(content, "        \"{}\"", key).unwrap();
                    }
                    writeln!(content, "      ];").unwrap();
                }

                if let Some(ref hash) = user.hashed_password {
                    writeln!(content, "      hashedPassword = \"{}\";", hash).unwrap();
                }

                writeln!(content, "    }};").unwrap();
            }

            // Legacy Samba users (backwards compatibility)
            for user in &legacy_samba_users {
                if created_users.contains(&user.username) {
                    continue;
                }

                writeln!(content, "    \"{}\" = {{", user.username).unwrap();
                writeln!(content, "      isSystemUser = true;").unwrap();
                writeln!(content, "      group = \"users\";").unwrap();
                if !user.description.is_empty() {
                    writeln!(content, "      description = \"{}\";", user.description).unwrap();
                }
                let extra_groups: Vec<String> = user
                    .groups
                    .iter()
                    .filter(|g| *g != "users" && *g != "samba")
                    .map(|g| format!("\"{}\"", g))
                    .collect();
                if !extra_groups.is_empty() {
                    writeln!(
                        content,
                        "      extraGroups = [ {} ];",
                        extra_groups.join(" ")
                    )
                    .unwrap();
                }
                writeln!(content, "      home = \"/var/empty\";").unwrap();
                writeln!(
                    content,
                    "      shell = \"/run/current-system/sw/bin/nologin\";"
                )
                .unwrap();
                writeln!(content, "      createHome = false;").unwrap();
                writeln!(content, "    }};").unwrap();
            }

            writeln!(content, "  }};").unwrap();
        }

        writeln!(content, "}}").unwrap();

        self.write_file(dir.join("users.nix"), &content).await
    }

    /// Write a mount entry.
    fn write_mount(&self, content: &mut String, mount: &PersistentMount) -> Result<(), NixError> {
        writeln!(content, "    \"{}\" = {{", mount.path).unwrap();
        writeln!(content, "      device = \"{}\";", mount.device).unwrap();
        writeln!(content, "      fsType = \"{}\";", mount.fstype).unwrap();

        if !mount.options.is_empty() {
            let options: Vec<String> = mount.options.iter().map(|o| format!("\"{}\"", o)).collect();
            writeln!(content, "      options = [ {} ];", options.join(" ")).unwrap();
        }

        writeln!(content, "    }};").unwrap();
        Ok(())
    }

    /// Write an SMB share entry.
    fn write_smb_share(&self, content: &mut String, share: &SmbShare) -> Result<(), NixError> {
        writeln!(content).unwrap();
        writeln!(content, "      \"{}\" = {{", share.name).unwrap();
        writeln!(content, "        path = \"{}\";", share.path).unwrap();

        if !share.comment.is_empty() {
            writeln!(content, "        comment = \"{}\";", share.comment).unwrap();
        }

        writeln!(
            content,
            "        browseable = \"{}\";",
            bool_to_yesno(share.browseable)
        )
        .unwrap();
        writeln!(
            content,
            "        \"read only\" = \"{}\";",
            bool_to_yesno(share.read_only)
        )
        .unwrap();
        writeln!(
            content,
            "        \"guest ok\" = \"{}\";",
            bool_to_yesno(share.guest_ok)
        )
        .unwrap();

        if share.guest_only {
            writeln!(content, "        \"guest only\" = \"yes\";").unwrap();
        }

        let mut valid_users: Vec<String> = share.valid_users.clone();
        let mut invalid_users: Vec<String> = share.invalid_users.clone();
        let mut write_list: Vec<String> = share.write_list.clone();
        let mut read_list: Vec<String> = share.read_list.clone();

        use crate::state::PrivilegeLevel;
        for priv_entry in &share.privileges {
            let name = if priv_entry.is_group {
                format!("@{}", priv_entry.name)
            } else {
                priv_entry.name.clone()
            };

            match priv_entry.permission {
                PrivilegeLevel::NoAccess => {
                    if !invalid_users.contains(&name) {
                        invalid_users.push(name);
                    }
                }
                PrivilegeLevel::ReadOnly => {
                    if !valid_users.contains(&name) {
                        valid_users.push(name.clone());
                    }
                    if !read_list.contains(&name) {
                        read_list.push(name);
                    }
                }
                PrivilegeLevel::ReadWrite => {
                    if !valid_users.contains(&name) {
                        valid_users.push(name.clone());
                    }
                    if !write_list.contains(&name) {
                        write_list.push(name);
                    }
                }
            }
        }

        if !valid_users.is_empty() {
            writeln!(
                content,
                "        \"valid users\" = \"{}\";",
                valid_users.join(" ")
            )
            .unwrap();
        }
        if !invalid_users.is_empty() {
            writeln!(
                content,
                "        \"invalid users\" = \"{}\";",
                invalid_users.join(" ")
            )
            .unwrap();
        }
        if !write_list.is_empty() {
            writeln!(
                content,
                "        \"write list\" = \"{}\";",
                write_list.join(" ")
            )
            .unwrap();
        }
        if !read_list.is_empty() {
            writeln!(
                content,
                "        \"read list\" = \"{}\";",
                read_list.join(" ")
            )
            .unwrap();
        }

        if !share.hosts_allow.is_empty() {
            writeln!(
                content,
                "        \"hosts allow\" = \"{}\";",
                share.hosts_allow.join(" ")
            )
            .unwrap();
        }
        if !share.hosts_deny.is_empty() {
            writeln!(
                content,
                "        \"hosts deny\" = \"{}\";",
                share.hosts_deny.join(" ")
            )
            .unwrap();
        }

        if let Some(ref force_user) = share.force_user {
            writeln!(content, "        \"force user\" = \"{}\";", force_user).unwrap();
        }
        if let Some(ref force_group) = share.force_group {
            writeln!(content, "        \"force group\" = \"{}\";", force_group).unwrap();
        }

        writeln!(
            content,
            "        \"create mask\" = \"{}\";",
            share.create_mask
        )
        .unwrap();
        writeln!(
            content,
            "        \"directory mask\" = \"{}\";",
            share.directory_mask
        )
        .unwrap();

        if let Some(ref force_create) = share.force_create_mode {
            writeln!(
                content,
                "        \"force create mode\" = \"{}\";",
                force_create
            )
            .unwrap();
        }
        if let Some(ref force_dir) = share.force_directory_mode {
            writeln!(
                content,
                "        \"force directory mode\" = \"{}\";",
                force_dir
            )
            .unwrap();
        }

        if share.inherit_acls {
            writeln!(content, "        \"inherit acls\" = \"yes\";").unwrap();
        }
        if share.inherit_permissions {
            writeln!(content, "        \"inherit permissions\" = \"yes\";").unwrap();
        }

        writeln!(
            content,
            "        \"ea support\" = \"{}\";",
            bool_to_yesno(share.ea_support)
        )
        .unwrap();
        if share.store_dos_attributes {
            writeln!(content, "        \"store dos attributes\" = \"yes\";").unwrap();
        }

        writeln!(
            content,
            "        \"hide dot files\" = \"{}\";",
            bool_to_yesno(share.hide_dot_files)
        )
        .unwrap();
        writeln!(
            content,
            "        \"hide special files\" = \"{}\";",
            bool_to_yesno(share.hide_special_files)
        )
        .unwrap();

        writeln!(
            content,
            "        \"follow symlinks\" = \"{}\";",
            bool_to_yesno(share.follow_symlinks)
        )
        .unwrap();
        writeln!(
            content,
            "        \"wide links\" = \"{}\";",
            bool_to_yesno(share.wide_links)
        )
        .unwrap();

        if share.smb_encrypt != "auto" {
            writeln!(
                content,
                "        \"smb encrypt\" = \"{}\";",
                share.smb_encrypt
            )
            .unwrap();
        }

        let mut vfs_objs: Vec<String> = share.vfs_objects.clone();
        if share.recycle_bin && !vfs_objs.contains(&"recycle".to_string()) {
            vfs_objs.insert(0, "recycle".to_string());
        }
        if share.audit_enabled && !vfs_objs.contains(&"full_audit".to_string()) {
            vfs_objs.push("full_audit".to_string());
        }
        if share.time_machine && !vfs_objs.contains(&"fruit".to_string()) {
            vfs_objs.insert(0, "fruit".to_string());
            if !vfs_objs.contains(&"streams_xattr".to_string()) {
                vfs_objs.insert(1, "streams_xattr".to_string());
            }
        }

        if !vfs_objs.is_empty() {
            writeln!(
                content,
                "        \"vfs objects\" = \"{}\";",
                vfs_objs.join(" ")
            )
            .unwrap();
        }

        if share.recycle_bin {
            writeln!(content, "        \"recycle:repository\" = \".recycle\";").unwrap();
            writeln!(content, "        \"recycle:keeptree\" = \"yes\";").unwrap();
            writeln!(content, "        \"recycle:versions\" = \"yes\";").unwrap();
            if share.recycle_max_size > 0 {
                writeln!(
                    content,
                    "        \"recycle:maxsize\" = \"{}\";",
                    share.recycle_max_size
                )
                .unwrap();
            }
        }

        if share.audit_enabled {
            writeln!(content, "        \"full_audit:prefix\" = \"%u|%I|%S\";").unwrap();
            writeln!(content, "        \"full_audit:success\" = \"connect disconnect opendir mkdir rmdir closedir open close read pread write pwrite sendfile rename unlink chmod fchmod chown fchown chdir ftruncate lock\";").unwrap();
            writeln!(content, "        \"full_audit:failure\" = \"connect\";").unwrap();
            writeln!(content, "        \"full_audit:facility\" = \"local5\";").unwrap();
            writeln!(content, "        \"full_audit:priority\" = \"notice\";").unwrap();
        }

        if share.time_machine {
            writeln!(content, "        \"fruit:time machine\" = \"yes\";").unwrap();
        }

        if !share.extra_options.is_empty() {
            for line in share.extra_options.lines() {
                let line = line.trim();
                if !line.is_empty()
                    && !line.starts_with('#')
                    && let Some((key, value)) = line.split_once('=')
                {
                    writeln!(
                        content,
                        "        \"{}\" = \"{}\";",
                        key.trim(),
                        value.trim()
                    )
                    .unwrap();
                }
            }
        }

        writeln!(content, "      }};").unwrap();

        Ok(())
    }

    /// Write content to a file.
    async fn write_file(&self, path: impl AsRef<Path>, content: &str) -> Result<(), NixError> {
        fs::write(&path, content)
            .await
            .map_err(|e| NixError::Write(format!("{}: {}", path.as_ref().display(), e)))
    }

    /// Apply configuration with nixos-rebuild switch.
    pub async fn apply(&self) -> Result<RebuildResult, NixError> {
        self.generate_all().await?;
        self.rebuild(&["switch"]).await
    }

    /// Test configuration with dry-build.
    pub async fn dry_build(&self) -> Result<RebuildResult, NixError> {
        self.generate_all().await?;
        self.rebuild(&["dry-build"]).await
    }

    /// Build configuration without switching.
    #[allow(dead_code)]
    pub async fn build(&self) -> Result<RebuildResult, NixError> {
        self.generate_all().await?;
        self.rebuild(&["build"]).await
    }

    /// Execute nixos-rebuild with given arguments.
    async fn rebuild(&self, args: &[&str]) -> Result<RebuildResult, NixError> {
        info!("Running nixos-rebuild-ng {}", args.join(" "));

        let output = run("nixos-rebuild-ng", args)
            .await
            .map_err(|e| NixError::Rebuild(e.to_string()))?;

        if output.success {
            Ok(RebuildResult {
                success: true,
                message: "Configuration applied successfully".to_string(),
                output: output.stdout,
            })
        } else {
            Err(NixError::Rebuild(output.stderr))
        }
    }

    /// List available generations.
    pub async fn list_generations(&self) -> CmdResult<Vec<Generation>> {
        let lines = run_lines("nixos-rebuild-ng", &["list-generations"]).await?;

        let mut generations = Vec::new();
        for line in lines.iter().skip(1) {
            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.len() >= 4 {
                generations.push(Generation {
                    id: parts[0].parse().unwrap_or(0),
                    date: parts[1].to_string(),
                    time: parts[2].to_string(),
                    current: line.contains("(current)"),
                });
            }
        }

        Ok(generations)
    }

    /// Rollback to previous generation.
    pub async fn rollback(&self) -> Result<RebuildResult, NixError> {
        self.rebuild(&["switch", "--rollback"]).await
    }

    /// Switch to a specific generation.
    pub async fn switch_generation(&self, id: u32) -> Result<RebuildResult, NixError> {
        let gen_arg = format!("{}", id);
        self.rebuild(&["switch", "--switch-generation", &gen_arg])
            .await
    }

    /// Upgrade system (boot --upgrade) - applies at next reboot.
    pub async fn upgrade(&self) -> Result<RebuildResult, NixError> {
        self.rebuild(&["boot", "--upgrade"]).await
    }
}

/// Result of a nixos-rebuild operation.
#[derive(Debug, Clone, Serialize)]
pub struct RebuildResult {
    pub success: bool,
    pub message: String,
    pub output: String,
}

/// NixOS generation info.
#[derive(Debug, Clone, Serialize)]
pub struct Generation {
    pub id: u32,
    pub date: String,
    pub time: String,
    pub current: bool,
}

fn bool_to_yesno(b: bool) -> &'static str {
    if b { "yes" } else { "no" }
}
